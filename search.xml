<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python进阶指南]]></title>
    <url>%2F2018%2F04%2F04%2FPython%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[简介 记录了关于Python编程中的一些小技巧和黑科技，包括一些非常好用的官方库和第三方库（堪称神器）用于解决工作学习中遇到的各种问题。本文档并不详细解释所有提到的知识点和库，只提供解决某种类型问题的一种思路，详细的用法还需要进一步翻阅官方文档或者借助搜索引擎。由于 Python2.7 将会在2020年官方停止，Python3 才是未来，所以本文档的例子都在 Python3.6 上测试通过。本文档长期更新。 编程技巧高级语法解压序列解压序列赋值给多个变量，先看一个简单的例子 &gt;&gt;&gt; a,b,c = (1,2,3) &gt;&gt;&gt; print(a,b,c,sep=&apos; &apos;) 1 2 3 &gt;&gt;&gt; a,b = (1,2,3) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: too many values to unpack (expected 2) &gt;&gt;&gt; a,b,c,d = (1,2,3) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: not enough values to unpack (expected 4, got 3) 元组(1,2,3)解压并分别赋值给了a,b,c，如果接收的变量太少或者太多都会抛出异常。这时可以使用 * 来将多余的元素都赋值给这个变量。 &gt;&gt;&gt; a,*b,c = (1,2,3,4) &gt;&gt;&gt; print(&apos;a=%s b=%s c=%s&apos; % (a,b,c)) a=1 b=[2, 3] c=4 这种解压赋值可以用在任何可迭代对象上，也就是说字符串、列表、生成器、字典甚至文件对象都适用，不过字典会将 key 进行赋值。 &gt;&gt;&gt; a,b,c = {&apos;d&apos;:1,&apos;e&apos;:2,&apos;f&apos;:3} &gt;&gt;&gt; print(a,b,c,sep=&apos; &apos;) d e f &gt;&gt;&gt; f = open(&apos;/etc/passwd&apos;) &gt;&gt;&gt; a,b,*_ = f &gt;&gt;&gt; print(a,b,sep=&apos;&apos;) root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin 利用这个知识点还可以实现不借助第三方变量来交换两个变量的值 &gt;&gt;&gt; x,y = 1,2 &gt;&gt;&gt; print(x,y,sep=&apos; &apos;) 1 2 &gt;&gt;&gt; x,y = y,x &gt;&gt;&gt; print(x,y,sep=&apos; &apos;) 2 1 三目运算符像 C 和 Java 等都有一种叫三目运算符的东西 (expr) ? value1 : value2;，根据判断表达式的结果来从两个选择中取一个值，Python 中也有类似的东西，但是语法却完全不同的。 语法： value1 if expr else value2。当表达式的结果为真时，取 value1，为假时取 value2。 示例： &gt;&gt;&gt; b = 1 &gt;&gt;&gt; a = 2 if b != 1 else 3 &gt;&gt;&gt; print(a) 3 还有一个小技巧，Python 如果对 True 和 False 进行数学运算的时候，会把 True 当作 1，False 当作 0，所以还可以采用对迭代器进行切片的方式取值： &gt;&gt;&gt; True+1 2 &gt;&gt;&gt; True + False 1 &gt;&gt;&gt; (&apos;a&apos;,&apos;b&apos;)[1&gt;2] &apos;a&apos; &gt;&gt;&gt; (&apos;a&apos;,&apos;b&apos;)[1&lt;2] &apos;b&apos; 列表解析列表解析是根据已有的可迭代对象，高效的创建新列表的方法。 语法： [expression for iter_val in iterable] [expression for iter_val in iterable if cond_expr] 示例： 将所有的小写字母转为大写 &gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; [x.upper() for x in L] [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 将所有的小写字母转为大写并排除掉列表中的数字 &gt;&gt;&gt; L = [1, &apos;a&apos;, 2, &apos;c&apos;] &gt;&gt;&gt; [x.upper() for x in L if type(x) == type(str())] [&apos;A&apos;, &apos;C&apos;] 可以看到，对于一些简单的处理，用列表解析更简洁，而且因为Python的内部优化，其运行速度会比普通处理方法更快。 字典解析字典解析就是利用可迭代对象创建新的字典。 语法： {expression:expression for iter_val in iterable} {expression:expression for iter_val in iterable if cond_expr} 示例： 计算字符的 ASCII 码，然后以键值的形式保存在字典中 &gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;C&apos;, &apos;D&apos;] &gt;&gt;&gt; {x:ord(x) for x in L} {&apos;a&apos;: 97, &apos;b&apos;: 98, &apos;C&apos;: 67, &apos;D&apos;: 68} 过滤掉刚才字典中小写字母的键 &gt;&gt;&gt; D = {&apos;a&apos;: 97, &apos;b&apos;: 98, &apos;C&apos;: 67, &apos;D&apos;: 68} &gt;&gt;&gt; {x:y for x,y in D.items() if y &gt;= 65 and y &lt; 97} {&apos;C&apos;: 67, &apos;D&apos;: 68} 集合解析集合解析和列表解析用法一致，只不过使用和字典解析一样的大括号，并且返回的是一个集合。 语法： {expression for iter_val in iterable} {expression for iter_val in iterable if cond_expr} 示例： 将所有的小写字母转为大写，并且去掉重复的字母 &gt;&gt;&gt; L = [&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; {x.upper() for x in L} {&apos;B&apos;, &apos;A&apos;, &apos;C&apos;} 生成器表达式生成器表达式的用法和列表解析也非常相似，但是生成器表达式不同于列表解析的地方是它返回的是一个生成器。生成器表达式使用了惰性计算的机制。 语法： (expression for iter_val in iterable) (expression for iter_val in iterable if cond_expr) 示例： 将所有的小写字母转为大写并排除掉列表中的数字 &gt;&gt;&gt; L = [1, &apos;a&apos;, 2, &apos;c&apos;] &gt;&gt;&gt; g = (x.upper() for x in L if type(x) == type(str())) &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x7f8e1fa79468&gt; &gt;&gt;&gt; next(g) &apos;A&apos; &gt;&gt;&gt; next(g) &apos;C&apos; &gt;&gt;&gt; next(g) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration 函数式编程lambda先来看看 lambda 的一个简单例子： &gt;&gt;&gt; func = lambda x: x**2 &gt;&gt;&gt; func(2) 4 &gt;&gt;&gt; func(4) 16 可以这样理解，lambda 作为一个表达式，定义了一个匿名函数。lambda 的主体只能是一个表达式，而不是一个代码块，所以 lambda 只能封装有限的逻辑进去。表达式的结果就是 lambda 的返回值。 语法：lambda [arg1 [,arg2,.....argn]]:expression map语法：map(function, iterable, ...) map() 函数的第一个参数是一个方法，第二个参数开始是一个迭代器。如果同时存在多个迭代器，map() 会同时遍历所有的迭代器，遍历次数以最短的迭代器为准，每个迭代器的值都将作为参数传给 function。下面看看 map() 应该怎么用。 示例： 把列表中所有是数字的元素乘 2 &gt;&gt;&gt; L = [1, &apos;a&apos;, 2, &apos;c&apos;] &gt;&gt;&gt; list(map(lambda x: x*2 if type(x) == type(int()) else x, L)) [2, &apos;a&apos;, 4, &apos;c&apos;] Python3 的 map() 函数默认返回生成器，所以需要用 list() 函数将它转化为列表。这里传给 map() 函数的处理方法，使用的是 lambda 表达式生成的匿名函数，也可以将一个普通函数或者方法传给 map() 使用，比如： &gt;&gt;&gt; list(map(chr,[68,69,88])) [&apos;D&apos;, &apos;E&apos;, &apos;X&apos;] filter语法：filter(function, iterable) filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。Python3 的 filter() 也是返回一个生成器。 示例： 过滤掉列表中的偶数，只保留奇数 &gt;&gt;&gt; list(filter(lambda x: x%2,range(10))) [1, 3, 5, 7, 9] 当处理函数返回 True 时，列表元素会留下，返回 False 时，列表元素会被丢弃。1 会被作为 True，0 会被作为 False。 reduce语法：reduce(function, iterable[, initializer]) reduce() 函数会对参数序列中元素进行累积。reduce() 函数默认会先将迭代器的第一个和第二个元素传入 function 中来求值，之后将得到的新值和迭代器的第三个元素传入 function 中继续求值，直到迭代器遍历完毕后汇总结果。initializer 参数是一个可选参数，如果提供了此参数，则 reduce() 函数会直接将它的值作为运算的初始值与迭代器的第一个元素传入 function 中。 Python3 的 reduce() 不再是默认全局空间的了，用的时候需要先导入。 示例： 计算 1 到 100 的和 &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; reduce(lambda x,y: x+y, range(1,101)) 5050 &gt;&gt;&gt; reduce(lambda x,y: x+y, range(1,101),100) 5150 题外话：理解了 Python 中的 map() 和 reduce() 函数，也很容易理解 Hadoop 中的 MapReduce 计算模型了。 对字符串进行操作使用正则来分割字符串对字符串的分割通常是使用字符串的 split() 方法，但是这个方法有个局限就是每次只能按照一种分隔符来进行分割，而使用 re.split() 则可以使用正则表达式来进行分割。 &gt;&gt;&gt; import re &gt;&gt;&gt; s = &apos;abc 123;def,oe2&apos; &gt;&gt;&gt; re.split(r&apos;\s|;|,&apos;, s) [&apos;abc&apos;, &apos;123&apos;, &apos;def&apos;, &apos;oe2&apos;] 字符串开头或结尾匹配可能经常需要对一个url的协议头进行检测，或者对一个文件名的后缀进行检测，最简单的方法就是使用 str.startswith() 和 str.endswith() 方法了。 &gt;&gt;&gt; url = [&apos;http://127.0.0.1/&apos;,&apos;ftp://127.0.0.1/&apos;] &gt;&gt;&gt; fname = [&apos;hello.py&apos;, &apos;hi.c&apos;, &apos;hi.py&apos;, &apos;hi.js&apos;] &gt;&gt;&gt; [s for s in url if s.startswith(&apos;http:&apos;)] [&apos;http://127.0.0.1/&apos;] &gt;&gt;&gt; [s for s in fname if s.endswith((&apos;c&apos;,&apos;js&apos;))] [&apos;hi.c&apos;, &apos;hi.js&apos;] 需要注意的是，如果想匹配多个字符串开头或结尾，必须将多个匹配项放到元组内。 字符串匹配和搜索如果只是简单的匹配或者搜索字符串中特定的字符串，使用 str 类型的 find() 方法就可以了，但是如果想要完成更复杂的搜索，就要使用正则表达式了，Python的 re 模块提供了对正则表达式的支持 &gt;&gt;&gt; import re, os &gt;&gt;&gt; reg = re.compile(r&apos;inet addr:(.*?)\s&apos;, re.S) &gt;&gt;&gt; re.findall(reg, os.popen(&apos;ifconfig em1&apos;).read()) [&apos;192.168.4.6&apos;] 字符串搜索和替换对于简单的字符串替换，可以使用 str.replace() 方法。 &gt;&gt;&gt; text = &apos;yeah, but no, but yeah, but no, but yeah&apos; &gt;&gt;&gt; text.replace(&apos;yeah&apos;, &apos;yep&apos;) &apos;yep, but no, but yep, but no, but yep&apos; 对于复杂的替换可以使用 re.sub() 函数。 &gt;&gt;&gt; text = &apos;Today is 11/27/2012. PyCon starts 3/13/2013.&apos; &gt;&gt;&gt; import re &gt;&gt;&gt; re.sub(r&apos;(\d+)/(\d+)/(\d+)&apos;, r&apos;\3-\1-\2&apos;, text) &apos;Today is 2012-11-27. PyCon starts 2013-3-13.&apos; 如果想要忽略大小写的替换，可以在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。 &gt;&gt;&gt; text = &apos;UPPER PYTHON, lower python, Mixed Python&apos; &gt;&gt;&gt; re.findall(&apos;python&apos;, text, flags=re.IGNORECASE) [&apos;PYTHON&apos;, &apos;python&apos;, &apos;Python&apos;] &gt;&gt;&gt; re.sub(&apos;python&apos;, &apos;snake&apos;, text, flags=re.IGNORECASE) &apos;UPPER snake, lower snake, Mixed snake&apos; 对于文本搜索，难点在于正则表达式的编写。 删除字符串头尾部不需要的字符strip() 方法能用于删除开始或结尾的字符。 lstrip() 和 rstrip() 分别从左和从右执行删除操作。 默认情况下，这些方法会去除空白字符，但是也可以指定其他字符。 &gt;&gt;&gt; s = &apos; hello world \n&apos; &gt;&gt;&gt; s.strip() &apos;hello world&apos; &gt;&gt;&gt; s.lstrip() &apos;hello world \n&apos; &gt;&gt;&gt; s.rstrip() &apos; hello world&apos; &gt;&gt;&gt; &gt;&gt;&gt; t = &apos;-----hello=====&apos; &gt;&gt;&gt; t.lstrip(&apos;-&apos;) &apos;hello=====&apos; &gt;&gt;&gt; t.strip(&apos;-=&apos;) &apos;hello&apos; 字符串对齐在终端上打印长短不一的字符串时这个可能非常有用，对字符串的对其方法，可以使用字符串的 ljust() , rjust() 和 center() 方法 12345print('id'.ljust(10),'name'.ljust(10),'age'.ljust(10),sep='')print('-'*23)print('1'.ljust(10),'Tom'.ljust(10),'20'.ljust(10),sep='')print('2'.ljust(10),'Jack'.ljust(10),'21'.ljust(10),sep='')print('3'.ljust(10),'Alan'.ljust(10),'19'.ljust(10),sep='') 输出： [root@localhost ~]# python3 test.py id name age ----------------------- 1 Tom 20 2 Jack 21 3 Alan 19 这些方法都能接受一个可选的填充字符参数 &gt;&gt;&gt; a = &apos;Tom&apos; &gt;&gt;&gt; a.center(10,&apos;*&apos;) &apos;***Tom****&apos; 或者还可以使用更强大的内建函数 format()。 字符串拼接字符串拼接除了使用 + 号连接两个字符串，还有效率更高更快的 join() 方法， join() 适用于要拼接的字符串在一个可迭代对象中。 &gt;&gt;&gt; parts = [&apos;Is&apos;, &apos;Chicago&apos;, &apos;Not&apos;, &apos;Chicago?&apos;] &gt;&gt;&gt; &apos; &apos;.join(parts) &apos;Is Chicago Not Chicago?&apos; &gt;&gt;&gt; &apos;,&apos;.join(parts) &apos;Is,Chicago,Not,Chicago?&apos; &gt;&gt;&gt; &apos;&apos;.join(parts) &apos;IsChicagoNotChicago?&apos; 字符串插入变量可能经常会遇到动态生成字符串的场景，Python 提供了多种方式来实现这种需求 使用字符串拼接： &gt;&gt;&gt; s = &apos;Monday&apos; &gt;&gt;&gt; &apos;Today is &apos; + s &apos;Today is Monday&apos; 使用占位符： &gt;&gt;&gt; s = &apos;Hi, %s is %s&apos; &gt;&gt;&gt; s % (&apos;Today&apos;, &apos;Monday&apos;) &apos;Hi, Today is Monday&apos; 使用 str.format() 函数： &gt;&gt;&gt; info = &apos;Name: {name}, Age: {age}&apos; &gt;&gt;&gt; info.format(name=&apos;Tom&apos;, age=20) &apos;Name: Tom, Age: 20&apos; 使用格式化字符串（Python 3.6 +） &gt;&gt;&gt; name,age = &apos;Tom&apos;,20 &gt;&gt;&gt; f&apos;Name: {name}, Age: {age}&apos; &apos;Name: Tom, Age: 20&apos; 像操作文件一样操作字符串使用 io.StringIO() 和 io.BytesIO() 类来创建类文件对象操作字符串数据 &gt;&gt;&gt; s = io.StringIO() &gt;&gt;&gt; s.write(&apos;Hello World\n&apos;) 12 &gt;&gt;&gt; print(&apos;This is a test&apos;, file=s) 15 &gt;&gt;&gt; # Get all of the data written so far &gt;&gt;&gt; s.getvalue() &apos;Hello World\nThis is a test\n&apos; &gt;&gt;&gt; # Wrap a file interface around an existing string &gt;&gt;&gt; s = io.StringIO(&apos;Hello\nWorld\n&apos;) &gt;&gt;&gt; s.read(4) &apos;Hell&apos; &gt;&gt;&gt; s.read() &apos;o\nWorld\n&apos; &gt;&gt;&gt; io.StringIO 只能用于文本。如果你要操作二进制数据，要使用 io.BytesIO 类来代替 对列表/字典等操作对字典的值进行排序内置函数 sorted() 支持对可迭代对象的元素进行排序，并将结果作为列表返回。如果排序的元素也是一个可迭代对象，则可以指定使用这个元素的某个项进行排序。 &gt;&gt;&gt; d = {&apos;a&apos;:10,&apos;b&apos;:8,&apos;c&apos;:11} &gt;&gt;&gt; sorted(d.items(), key=lambda x:x[1]) [(&apos;b&apos;, 8), (&apos;a&apos;, 10), (&apos;c&apos;, 11)] 或者下面这样也可以，只不过只返回了键 &gt;&gt;&gt; sorted(d, key=lambda k:d[k]) [&apos;b&apos;, &apos;a&apos;, &apos;c&apos;] 同理，使用这个方法也可以找出字典的最小值和最大值，但是还有更好的方法。 字典的最大值和最小值 min() 和 max() 函数可以快速得出一个可迭代对象的最小值和最大值，如果只是想简单的知道字典中的最大值或者最小值，调用字典的 values() 方法，然后通过 min() 或者 max() 进行计算就解决了，但是显然就无法得出这个最大值的键了。 min() 和 max() 函数也提供有 key 参数，使用上和 sorted 相同。 &gt;&gt;&gt; d = {&apos;a&apos;:10,&apos;b&apos;:8,&apos;c&apos;:11} &gt;&gt;&gt; min(d, key=lambda k:d[k]) &apos;b&apos; &gt;&gt;&gt; max(d, key=lambda k:d[k]) &apos;c&apos; &gt;&gt;&gt; max(d.items(), key=lambda d:d[1]) (&apos;c&apos;, 11) 去除列表/字典中的重复元素/值去除列表重复元素可以使用 set() 函数将列表转换为集合，其中重复的值就去掉了，但是这样也将丢失列表元素的顺序，而且也并不适合字典类型的数据。我们可以模仿 sorted() 函数来自己写一个完成需求的函数。 1234567def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val) &gt;&gt;&gt; d = {&apos;a&apos;:10,&apos;b&apos;:8,&apos;c&apos;:11,&apos;d&apos;:8} &gt;&gt;&gt; l = [2,1,3,1,2] &gt;&gt;&gt; list(dedupe(d, lambda x:d[x])) [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; list(dedupe(l)) [2, 1, 3] 快速找到字典公共键可以利用集合的特性，计算多个字典键的交集即可。 &gt;&gt;&gt; d1 = {&apos;a&apos;:1,&apos;c&apos;:2,&apos;f&apos;:3} &gt;&gt;&gt; d2 = {&apos;a&apos;:2,&apos;c&apos;:4,&apos;d&apos;:3} &gt;&gt;&gt; d3 = {&apos;b&apos;:2,&apos;e&apos;:4,&apos;c&apos;:3} &gt;&gt;&gt; set(d1.keys()) &amp; set(d2.keys()) &amp; set(d3.keys()) {&apos;c&apos;} &gt;&gt;&gt; d1.keys() &amp; d2.keys() &amp; d3.keys() {&apos;c&apos;} 集合之间可以进行 -（差集），&amp;（交集），|（并集）计算。 如果字典比较多，还可以使用 map() 和 reduce() 来处理 &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; reduce(lambda x,y:x&amp;y, map(dict.keys, [d1,d2,d3])) {&apos;c&apos;} 给切片一个名字如果程序里需要用到大量的切片，这样会很严重的降低程序的可读性。但是如果给切片范围起一个名字，代码就更清晰可读了。 使用 slice() 函数创建一个切片对象，可以被用在任何切片允许的地方 &gt;&gt;&gt; INFO = &quot;00:50:56:C0:00:08-192.168.198.1&quot; &gt;&gt;&gt; mac = slice(None,17) &gt;&gt;&gt; ip = slice(18,None) &gt;&gt;&gt; INFO[mac] &apos;00:50:56:C0:00:08&apos; &gt;&gt;&gt; INFO[ip] &apos;192.168.198.1&apos; 标准库数据结构处理collections 数据类型容器collections.namedtuplePython中普通的 tuple 数据类型的元素是不可修改的，而且 tuple 的长度是不可变的，因此 tuple 的资源消耗少于 list。tuple 的元素访问只能通过索引，而在程序中通过索引访问元素的代码可读性太差，而 collections.namedtuple 则拓展了 tuple 的能力，允许以面向对象的方式访问其中的元素，而且资源消耗却跟 tuple 差不多。 示例： &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Student = namedtuple(&apos;Student&apos;,[&apos;name&apos;,&apos;age&apos;,&apos;sex&apos;]) &gt;&gt;&gt; s = Student(name=&apos;Tom&apos;,age=16,sex=&apos;boy&apos;) &gt;&gt;&gt; s Student(name=&apos;Tom&apos;, age=16, sex=&apos;boy&apos;) &gt;&gt;&gt; s[0] &apos;Tom&apos; &gt;&gt;&gt; s.name &apos;Tom&apos; &gt;&gt;&gt; isinstance(s, tuple) True 可以看到 namedtuple 类型是 tuple 类型的子类。任何可以使用 tuple 的地方就可以使用 namedtuple collections.OrderedDictPython的默认 dict 类型是无序的，使用 OrderedDict 则可以实现有序的字典。 注意：Python3.6 换了种 dict 类型的实现方式，所以 Python3.6 的字典变成有序的了，但是使用 OrderedDict 可以确保在之前支持 OrderedDict 的版本中创建有序字典。 &gt;&gt;&gt; from collections import OrderedDict &gt;&gt;&gt; d = OrderedDict(c=1,b=2,a=3) &gt;&gt;&gt; d.keys() odict_keys([&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]) &gt;&gt;&gt; isinstance(d,dict) True OrderedDict 是 dict 类型的子类，使用 dict 类型的地方也完全可以使用 OrderedDict collections.dequecollections.deque 是一个双端队列。顾名思义 deque 提供了在队列两端插入和删除的操作，如果创建 deque 对象的时候指定了队列长度，当队列满了从一端继续插入元素的时候，另一端的元素就会被移除。如果没有指定队列长度，就可以在两端无限插入元素了，当然前提是内存够用。 &gt;&gt;&gt; import collections &gt;&gt;&gt; d = collections.deque(maxlen=3) &gt;&gt;&gt; d.append(1) &gt;&gt;&gt; d.append(2) &gt;&gt;&gt; d.append(3) &gt;&gt;&gt; d deque([1, 2, 3], maxlen=3) &gt;&gt;&gt; d.append(4) &gt;&gt;&gt; d deque([2, 3, 4], maxlen=3) deque 对象的 rotate 方法比较有意思，相当于从队列右边弹出几个元素插入到左边来。下面看一个有趣的小例子，模拟一个无限循环的进度条。 123456789import sysimport timefrom collections import dequeloading = deque('&gt;--------------------')while True: sys.stdout.write('\r[%s]' % ''.join(loading)) loading.rotate(1) sys.stdout.flush() time.sleep(0.1) Python的 list（列表）对象不也提供了两端插入或者删除元素的方法吗，但是 deque 在两端插入或删除的时间复杂度是 O(1)，而 list 是 O(N)。 collections.CounterCounter 工具用于支持便捷和快速地统计可迭代对象中每个元素出现的次数，而且速度非常快。 快速的统计一个文本中，出现次数最多的三个字符 &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; c = Counter(open(&apos;abc.txt&apos;).read()) &gt;&gt;&gt; c.most_common(3) [(&apos;，&apos;, 312256), (&apos; &apos;, 296920), (&apos;的&apos;, 180567)] Counter 是 dict 类型的子类，以迭代器的每个元素为键，元素出现的次数为值。 collections.ChainMap当需要从多个字典中执行某些操作，比如检测某些键或值是否存在，使用 ChainMap 函数可以将多个字典逻辑上合并为一个字典。 &gt;&gt;&gt; from collections import ChainMap &gt;&gt;&gt; a = {&apos;x&apos;: 1, &apos;z&apos;: 3 } &gt;&gt;&gt; b = {&apos;y&apos;: 2, &apos;z&apos;: 4 } &gt;&gt;&gt; c = ChainMap(a,b) &gt;&gt;&gt; print(c[&apos;x&apos;],c[&apos;y&apos;],c[&apos;z&apos;]) 1 2 3 &gt;&gt;&gt; del c[&apos;z&apos;] &gt;&gt;&gt; c[&apos;z&apos;] 4 &gt;&gt;&gt; a {&apos;x&apos;: 1} 如果出现重复键，第一次找到的键被返回，如果对新产生的字典做操作，更改也会映射到原来的字典上去。如果只考虑合并两个字典，可以使用字典的 update 方法。 heapq 堆队列算法实现排序堆是一个二叉树，其中每个父节点的值都小于或者等于其所有子节点的值。整个堆的最小元素总是位于二叉树的根节点。Python 的 heapq 模块提供了对堆的支持。 如何获取一个无序列表最大的十个元素和最小的十个元素呢，这里试试使用 list 数据类型的实现和使用 heapq 的实现。 list 的实现12345678import timeimport randomL = [random.randint(1,10000000) for x in range(5000000)]now = time.time()L.sort()print('Max: %s' % L[-10:])print('Min: %s' % L[:10])print('Used time: %s sec' % str(time.time()-now)) 结果： Max: [9999984, 9999989, ...... , 9999998, 9999999] Min: [2, 2, 3, 5, 5, 7, 10, 12, 14, 16] Used time: 5.01489806175 sec heapq 的实现12345678import timeimport heapqimport randomL = [random.randint(1,10000000) for x in range(5000000)]now = time.time()print('Max: %s' % heapq.nlargest(10, L))print('Min: %s' % heapq.nsmallest(10, L))print('Used time: %s sec' % str(time.time()-now)) 结果： Max: [10000000, 9999999, ...... , 9999989, 9999988] Min: [2, 6, 7, 7, 8, 8, 8, 10, 11, 13] Used time: 1.21054005623 sec 实现一个优先级队列先看这样一个例子： &gt;&gt;&gt; a = [] &gt;&gt;&gt; heapq.heappush(a,[-2,2,&apos;a&apos;]) &gt;&gt;&gt; heapq.heappush(a,[-1,5,&apos;b&apos;]) &gt;&gt;&gt; heapq.heappush(a,[-1,3,&apos;c&apos;]) &gt;&gt;&gt; a [[-2, 2, &apos;a&apos;], [-1, 5, &apos;b&apos;], [-1, 3, &apos;c&apos;]] &gt;&gt;&gt; heapq.heappop(a) [-2, 2, &apos;a&apos;] &gt;&gt;&gt; heapq.heappop(a) [-1, 3, &apos;c&apos;] &gt;&gt;&gt; heapq.heappop(a) [-1, 5, &apos;b&apos;] 使用 heappush 向一个队列中插入一个列表元素，先使用列表的第一个元素来排序，如果第一个元素相同，则使用第二个元素排序，如果只有一个字母的话，将使用 ASCII 码进行排序。 利用这个特性，可以使用 heapq 来实现一个优先级队列，下面看代码： 12345678910111213import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] push 方法中传入元素和它的优先级，因为 heapq 中值越小的就越在队列开头，所以插入到队列的时候要将优先级取负数。而 _index 的作用就是如果出现优先级相同的元素，就根据这个值来排序，而每插入一个元素，_index 的值都会增加1，所以后面插入的元素优先级就小于之前插入的元素了。 接下来看看效果如何： &gt;&gt;&gt; q = PriorityQueue() &gt;&gt;&gt; q.push(&apos;Bob&apos;, 2) &gt;&gt;&gt; q.push(&apos;Tom&apos;, 8) &gt;&gt;&gt; q.push(&apos;Jack&apos;, -5) &gt;&gt;&gt; q.pop() &apos;Tom&apos; &gt;&gt;&gt; q.pop() &apos;Bob&apos; &gt;&gt;&gt; q.pop() &apos;Jack&apos; Tom 的优先级最高，所以 Tom 被最先弹出了，一个简单的优先级队列就完成了。如果需要在多个线程中使用同一个队列，可以加入锁和信号量机制。 operator 内置操作符的函数接口operator.itemgetter如果有一个字典列表，想根据某个或某几个字典字段来排序这个列表。通过使用 operator 模块的 itemgetter 函数，可以非常容易的排序这样的数据结构。 &gt;&gt;&gt; from operator import itemgetter &gt;&gt;&gt; rows = [ ... {&apos;id&apos;:1000, &apos;name&apos;:&apos;Tom&apos;, &apos;age&apos;: 18}, ... {&apos;id&apos;:1001, &apos;name&apos;:&apos;Jack&apos;, &apos;age&apos;: 20}, ... {&apos;id&apos;:1003, &apos;name&apos;:&apos;Mei&apos;, &apos;age&apos;: 17}, ... {&apos;id&apos;:1002, &apos;name&apos;:&apos;Li&apos;, &apos;age&apos;: 17}, ... ] &gt;&gt;&gt; sorted(rows, key=itemgetter(&apos;name&apos;)) [{&apos;id&apos;: 1001, &apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 20}, {&apos;id&apos;: 1002, &apos;name&apos;: &apos;Li&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1003, &apos;name&apos;: &apos;Mei&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1000, &apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 18}] &gt;&gt;&gt; sorted(rows, key=itemgetter(&apos;id&apos;)) [{&apos;id&apos;: 1000, &apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 18}, {&apos;id&apos;: 1001, &apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 20}, {&apos;id&apos;: 1002, &apos;name&apos;: &apos;Li&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1003, &apos;name&apos;: &apos;Mei&apos;, &apos;age&apos;: 17}] itemgetter 函数也支持多个 keys，比如下面的代码，如果 age 相同的情况下，则按照 id 来排序 &gt;&gt;&gt; sorted(rows, key=itemgetter(&apos;age&apos;,&apos;id&apos;)) [{&apos;id&apos;: 1002, &apos;name&apos;: &apos;Li&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1003, &apos;name&apos;: &apos;Mei&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1000, &apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 18}, {&apos;id&apos;: 1001, &apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 20}] 也可以使用 sorted() 和 lambda 表达式实现上面的效果，比如 &gt;&gt;&gt; sorted(rows, key=lambda r:(r[&apos;age&apos;],r[&apos;id&apos;])) [{&apos;id&apos;: 1002, &apos;name&apos;: &apos;Li&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1003, &apos;name&apos;: &apos;Mei&apos;, &apos;age&apos;: 17}, {&apos;id&apos;: 1000, &apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 18}, {&apos;id&apos;: 1001, &apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 20}] 但是效率可能要比 itemgetter 慢一些。 operator.attrgetteritemgetter 是获取字典的每一项，如果是将数据保存在对象实例的属性中，则可以使用 attrgetter 来获取 1234567891011from operator import attrgetterclass User(): def __init__(self,id,name,age): self.id,self.name,self.age = id,name,age def __repr__(self): return 'User(id=%s, name=%s, age=%s)' % (self.id,self.name,self.age)users = [User(1000,'Tom',18),User(1001,'Jack',20), User(1003,'Mei',17),User(1002,'Li',17)]sorted(users, key=attrgetter('id'))sorted(users, key=attrgetter('age','id')) 输出： &gt;&gt;&gt; sorted(users, key=attrgetter(&apos;id&apos;)) [User(id=1000, name=Tom, age=18), User(id=1001, name=Jack, age=20), User(id=1002, name=Li, age=17), User(id=1003, name=Mei, age=17)] &gt;&gt;&gt; sorted(users, key=attrgetter(&apos;age&apos;,&apos;id&apos;)) [User(id=1002, name=Li, age=17), User(id=1003, name=Mei, age=17), User(id=1000, name=Tom, age=18), User(id=1001, name=Jack, age=20)] 同理，如果不想用 attrgetter 也可以自己用 lambda 实现功能。 itertools 操作迭代对象的库itertools.groupby如果有一个包含字典或者对象实例的列表，想根据某个字段进行分组迭代访问，可以使用 groupby 函数。 1234567rows = [ &#123;'id':1000, 'name':'Tom', 'age': 18&#125;, &#123;'id':1001, 'name':'Jack', 'age': 20&#125;, &#123;'id':1003, 'name':'Mei', 'age': 17&#125;, &#123;'id':1002, 'name':'Li', 'age': 17&#125;, &#123;'id':1004, 'name':'Ani', 'age': 20&#125;] 首先需要排序，然后才可以分组 1234567from operator import itemgetterfrom itertools import groupbyrows.sort(key=itemgetter('age'))for age,items in groupby(rows, key=itemgetter('age')): print('age = %s:' % age) for i in items: print(' ',i) 输出： age = 17: {&apos;id&apos;: 1003, &apos;name&apos;: &apos;Mei&apos;, &apos;age&apos;: 17} {&apos;id&apos;: 1002, &apos;name&apos;: &apos;Li&apos;, &apos;age&apos;: 17} age = 18: {&apos;id&apos;: 1000, &apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 18} age = 20: {&apos;id&apos;: 1001, &apos;name&apos;: &apos;Jack&apos;, &apos;age&apos;: 20} {&apos;id&apos;: 1004, &apos;name&apos;: &apos;Ani&apos;, &apos;age&apos;: 20} 文件处理固定大小的文件迭代如果有个文本文件，迭代文件对象最好是按行读取，但如果是二进制文件，则最好是每次读取固定大小的字节。 iter() 函数有个不常用的用法是如果传入了两个参数，第一个参数必须是一个可调用对象，第二个参数是结束标志，如果迭代过程中遇到了这个结束标志，迭代就结束了。可以利用这个性质来实现文件按固定字节读取。 &gt;&gt;&gt; f = open(&apos;/bin/bash&apos;,&apos;rb&apos;) &gt;&gt;&gt; i = iter(lambda :f.read(10), b&apos;&apos;) &gt;&gt;&gt; next(i) b&apos;\x7fELF\x02\x01\x01\x00\x00\x00&apos; &gt;&gt;&gt; next(i) b&apos;\x00\x00\x00\x00\x00\x00\x02\x00&gt;\x00&apos; &gt;&gt;&gt; next(i) b&apos;\x01\x00\x00\x00`\x05B\x00\x00\x00&apos; gzip/bz2 文件解压缩gzip 和 bz2 为Python提供了对文件进行 gz 和 bz2 格式的解压缩。 文件压缩： &gt;&gt;&gt; import gzip &gt;&gt;&gt; f = gzip.open(&apos;/tmp/test.gz&apos;,&apos;wt&apos;) &gt;&gt;&gt; f.write(&apos;Hello gzip&apos;) 10 &gt;&gt;&gt; f.close() gzip.open() 和 open() 函数一样，根据文件模式来判断对文件的读写方式，如果对文本文件压缩，使用 wt 文件模式，读取压缩文件使用 rt 文件模式。 文件解压： &gt;&gt;&gt; import gzip &gt;&gt;&gt; f = gzip.open(&apos;/tmp/test.gz&apos;,&apos;rt&apos;) &gt;&gt;&gt; f.read() &apos;Hello gzip&apos; bz2 和 gzip 的使用方式一致。压缩文件的时候还可以传入一个压缩等级的参数 默认是 compresslevel=9，打开的文件可以是一个文件名，也可以是一个类文件对象上，比如一个套接字对象、一个管道等。 mmap 内存映射文件对文件修改的场景还是经常遇到的，但是如果要修改一个非常大的文件，传统的读取文件，修改文件，写回文件的方式就非常不合适了。 第三方库chatdetpyinstallergeventbottlegunicorn附录参考资料： Python3-cookbook Python3.6 官方文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令基础]]></title>
    <url>%2F2018%2F04%2F04%2Fgit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。 源代码有必要管理起吗？ 1.0 2.0 // svn,vss,vcs…. git 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus linus自己写了一个版本管理的工具(Git) Git安装初始化Git仓储/(仓库) 这个仓库会存放，git对我们项目代码进行备份的文件 在项目目录右键打开 git bash 命令: git init 自报家门 就是在git中设置当前使用的用户是谁 每一次备份都会把当前备份者的信息存储起来 命令: 配置用户名:git config --global user.name &quot;xiaoming&quot; 配置邮箱: git config --global user.email &quot;xm@sina.com&quot; 把大象放到冰箱要几步 打开冰箱门 放大象 关上冰箱 把代码存储到.git仓储中 1.把代码放到仓储的门口 git add ./readme.md 所指定的文件放到大门口 git add ./ 把所有的修改的文件添加到大门口 2.把仓储门口的代码放到里面的房间中去 git commit -m &quot;这是对这次添加的东西的说明&quot; 可以一次性把我们修改的代码放到房间里(版本库) git commit --all -m &quot;一些说明&quot; –all 表示是把所有修改的文件提交到版本库 查看当前的状态 可以用来查看当前代码有没有被放到仓储中去 命令: git status git中的忽略文件 .gitignore,在这个文件中可以设置要被忽略的文件或者目录。 被忽略的文件不会被提交仓储里去. 在.gitignore中可以书写要被忽略的文件的路径，以/开头， 一行写一个路径，这些路径所对应的文件都会被忽略， 不会被提交到仓储中 写法 /.idea 会忽略.idea文件 /js 会忽略js目录里的所有文件 /js/*.js 会忽略js目录下所有js文件 查看日志 git log 查看历史提交的日志 git log --oneline 可以看到简洁版的日志 回退到指定的版本 git reset --hard Head~0 表示回退到上一次代码提交时的状态 git reset --hard Head~1 表示回退到上上次代码提交时的状态 git reset --hard [版本号] 可以通过版本号精确的回退到某一次提交时的状态 git reflog 可以看到每一次切换版本的记录:可以看到所有提交的版本号 分支 默认是有一个主分支master 创建分支 git branch dev 创建了一个dev分支 在刚创建时dev分支里的东西和master分支里的东西是一样的 切换分支 git checkout dev 切换到指定的分支,这里的切换到名为dev的分支git branch 可以查看当前有哪些分支 合并分支 git merge dev 合并分支内容,把当前分支与指定的分支(dev),进行合并 当前分支指的是git branch命令输出的前面有*号的分支 合并时如果有冲突，需要手动去处理，处理后还需要再提交一次. GitHub https://github.com 不是git,只是一个网站 只不过这个网站提供了允许别通过git上传代码的功能 提交代码到github(当作git服务器来用) git push [地址] master 示例: git push https://github.com/huoqishi/test112.git master master 会把当前分支的内容上传到远程的master分支上 git pull [地址] master 示例: git pull https://github.com/huoqishi/test112.git master 会把远程分支的数据得到:(注意本地-要初始一个仓储!) git clone [地址] 会得到远程仓储相同的数据,如果多次执行会覆盖本地内容。 流行框架 ssh方式上传代码 公钥 私钥,两者之间是有关联的。 生成公钥,和私钥 ssh-keygen -t rsa -C &quot;xiaoming@sina.com&quot; 在push和pull操作进 先pull , 再push 当我们在push时，加上-u参数，那么在下一次push时我们只需要写上git push就能上传我们的代码。(加上-u之后，git会把当前分支与远程的指定的分支进行关联。git push origin master)]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
